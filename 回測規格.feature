# -----------------------------------------------------------------------------------------
# [檔案功能說明]
# 這是一份需求規格文件，定義了「回測系統」的所有行為邏輯。
# 它的功能是做為開發的「藍圖」與測試的「標準」。
# 每一段 "場景 (Scenario)" 都對應到程式碼中必須處理的一種狀況。
# -----------------------------------------------------------------------------------------

目標:回測系統
# [說明] 定義這個功能的名稱與目標。
# 目標：驗證交易策略在過去的表現。

做為一個量化交易者，我需要知道我的交易策略在歷史數據上的表現，以便優化和改進策略。
# [說明] 這是「使用者故事 (User Story)」。
# 格式：作為一個<角色>，我想要<功能>，以便<目的>。
# 這幫助開發者理解為什麼要寫這個功能。

背景:
# [說明] 背景 (Background) 定義了所有場景的共同前提。
# 也就是說，下面每一個測試場景發生前，這些條件都必須先成立。

  假設我有一個交易策略
  # 代表程式必須能載入策略 (load_strategy)。

  並且我有歷史市場數據
  # 代表程式必須讀取到了 K 線資料 (df)。

  並且每次開倉平倉都會依設定扣除手續費、滑點等交易費用
  # 代表計算損益時，不能只算價差，一定要扣成本 (Fee & Slippage)，否則回測會失真。

場景: 開倉
# [說明] 測試最基本的買入/賣空邏輯。
  假設我的策略觸發多或空信號
  # 當 row['signal'] == 1 或 -1 時。
  
  並且我的餘額足夠進行交易
  # 這是開倉的前提 (Cash > Margin + Fee)。
  
  當我在歷史數據中執行開倉操作
  # 執行 position.open()。
  
  那麼我應該在回測系統中記錄這次開倉交易
  # stats.log 裡面要多一筆 "開倉" 的紀錄。
  
  並且我的持倉應該相應增加
  # position.size 應該變動 (例如從 0 變成 1)。
  
  並且先記錄我這次開倉消耗的交易費用
  # 現金 (Cash) 應該立刻扣除開倉手續費。

場景: 平倉
# [說明] 測試獲利了結或認賠出場的邏輯。
  假設我的策略觸發平倉信號
  # 當策略發出出場指令 (例如 signal 反向或呼叫 close)。
  
  當我在歷史數據中執行平倉操作
  # 執行 position.close()。
  
  那麼我應該在回測系統中記錄這次平倉交易
  # stats.log 裡面要多一筆 "平倉" 的紀錄。
  
  並且我的持倉應該相應減少
  # position.size 應該歸零或減少。
  
  並且計算盈虧時需要算上開倉時產生的交易費用
  # 淨利 = (賣價 - 買價) * 數量 - 開倉手續費 - 平倉手續費。
  
  並且餘額應該更新以反映這次交易的盈虧
  # stats.cash 應該加上 PnL。

場景: 止盈
# [說明] 測試 Take Profit (TP) 機制。
  假設我的策略觸發止盈信號
  # 當價格觸碰到我們預設的 TP 價格。
  
  當我在歷史數據中執行止盈操作
  # 觸發 position.trigger_TP()。
  
  那麼我應該在回測系統中記錄這次止盈交易
  # 記錄一筆狀態為 "平倉" 的交易，且價格為 TP 價。
  
  並且我的持倉應該平倉全部
  # 通常止盈是全平 (Close All)。

場景: 止損
# [說明] 測試 Stop Loss (SL) 機制，這是保護本金最重要的功能。
  假設我的策略觸發止損信號
  # 當價格觸碰到我們預設的 SL 價格。
  
  當我在歷史數據中執行止損操作
  # 觸發 position.trigger_SL()。
  
  那麼我應該在回測系統中記錄這次止損交易
  # 記錄一筆狀態為 "平倉" 的交易，且價格為 SL 價。
  
  並且我的持倉應該平倉全部
  # 止損通常也是全平，防止虧損擴大。

場景: 加倉
# [說明] 測試 Pyramiding (金字塔式加倉)。對應 config["下單設定"]["pyramiding"]。
  假設我在設定中允許加倉操作
  # config 設定 pyramiding: true。
  
  當我擁有倉位並且策略再次觸發與開倉相同的信號
  # 已經有多單，策略又說「買進」。
  
  那麼我應該執行開倉操作以增加持倉
  # 再次呼叫 position.open()。
  
  並且我應該在回測系統中記錄這次加倉交易
  # 記錄新的開倉動作，且均價 (Avg Price) 應重新計算。

場景: 反手
# [說明] 測試 Reverse (反手策略)。對應 config["下單設定"]["reverse"]。
  假設我在設定中允許反手操作
  # config 設定 reverse: true。
  
  當我擁有倉位並且策略觸發與開倉相反的信號
  # 例如手上有「多單」，但策略突然說「做空」。
  
  那麼我的持倉應該先平倉全部然後執行開倉操作
  # 這是兩步動作：1. Sell Close (平多) 2. Sell Open (開空)。
  
  並且我應該在回測系統中記錄這次反手交易
  # Log 裡應該要看到一筆平倉，緊接著一筆開倉。

場景: 槓桿交易
# [說明] 測試 Leverage (槓桿)。對應 config["下單設定"]["leverage"]。
  假設我設定了槓桿倍數
  # 例如 leverage: 10。
  
  當我執行開倉操作
  # 計算 size 時。
  
  那麼我的實際持倉量應該是根據槓桿倍數計算的
  # Size = 本金 * 10 / 價格。持倉量會比沒開槓桿大 10 倍。
  
  並且我的餘額應該反映出槓桿交易所需的保證金
  # 雖然這裡主要是回測，但邏輯上系統要檢查保證金是否足夠。

場景: 同時出現兩種操作信號
# [說明] 這是「邊界情況 (Edge Case)」的處理邏輯。
  當我的策略同時觸發止盈止損和開倉信號
  # 這種情況常發生在同一根 K 棒震盪很大時。
  
  那麼系統應該先執行止盈止損操作然後再執行開倉操作
  # 邏輯順序：先結算舊的單子 (SL/TP)，再開新的單子。這避免了保證金計算錯誤。

場景: 資金不足
# [說明] 測試例外處理 (Exception Handling)。
  假設我的餘額低於開一手倉位所需的金額
  # Cash < Margin + Fee。
  
  當策略觸發開倉信號
  # 想買。
  
  那麼系統應該忽略這次開倉信號
  # 不能讓 Cash 變成負數，直接 return。
  
  並且記錄一次因資金不足而錯過的交易
  # logging.warning("[INSUFFICIENT_FUNDS]")，這對優化策略很重要，可能代表本金設太少。

場景: 固定價值開倉模式
# [說明] 對應 config order_mode: "price"。
  假設我設定的下單模式是固定價值模式
  # 例如每次買 1000 USDT。
  
  當我執行開倉操作
  # 買入。
  
  那麼我應該根據設定的固定價值計算應該開多少量
  # Size = 1000 / Price。

場景: 固定手數開倉模式
# [說明] 對應 config order_mode: "fixed"。
  假設我設定的下單模式是固定手數模式
  # 例如每次買 0.1 顆 BTC。
  
  當我執行開倉操作
  # 買入。
  
  那麼我應該根據設定的固定手數進行開倉
  # Size = 0.1。

場景: 百分比開倉模式
# [說明] 對應 config order_mode: "percent"。這是最常用的複利模式。
  假設我設定的下單模式是百分比模式
  # 例如每次用 10% 資金。
  
  當我執行開倉操作
  # 買入。
  
  那麼我應該根據當前餘額的百分比計算應該開多少量
  # Size = (Cash * 0.1) / Price。

場景: 百分比止盈止損模式
# [說明] 對應 config tp_of_percent: true。
  假設我設定的止盈止損模式是百分比模式
  # 例如 10%。
  
  當我執行止盈止損操作
  # 計算價格。
  
  那麼我應該根據開倉價格的百分比計算止盈止損價格
  # Target = Entry_Price * (1 ± 0.1)。

場景: 固定價差止盈止損模式
# [說明] 對應 config tp_of_percent: false。
  假設我設定的止盈止損模式是固定價差模式
  # 例如 100 點。
  
  當我執行止盈止損操作
  # 計算價格。
  
  那麼我應該根據設定的固定價差計算止盈止損價格
  # Target = Entry_Price ± 100。

場景: 強制平倉
# [說明] 對應 config["max_hold"]。
  假設我設定了最長持倉時間為 N 根 K 棒
  # 防止資金被長時間佔用 (Opportunity Cost)。
  
  當持倉時間超過 N 根 K 棒
  # index - entry_index >= N。
  
  那麼系統應該在下一根 K 棒開盤時強制平倉全部
  # position.close_all()。

場景: 執行回測
# [說明] 測試 backtest.run() 的整合流程。
  假設我運行回測系統
  當我將交易策略應用於歷史市場數據
  那麼我應該依照開倉、平倉、止盈、止損、加倉、反手等規則進行交易
  
  並且我應該看到策略的績效報告
  # backtest.show()。
  
  並且報告應該包含收益率、最大回撤和夏普比率等指標
  # 確保 stats 類別有正確計算這些數學指標。

場景: 分析回測結果
# [說明] 這是回測的目的。
  假設我已經完成回測
  當我查看回測結果
  那麼我應該能夠識別策略的優勢和劣勢
  # 例如：勝率高但盈虧比低？或是最大回撤太大？
  
  並且我應該能夠根據結果調整我的交易策略
  # 根據數據去修改 config.json 或策略邏輯，進入下一次迭代。